# 同步IPC
总耗时：10825088  
3.18总耗时：4014537(平均一轮980)

## 代码路径
初始化-调用测试函数-生成辅助线程-测试  
### 主线程：
申请ipcbuffer-申请endpoint-申请创建辅助线程-循环接受并回复（不断调用reply_recv）  
reply_recv调用:trap（切换栈-保存寄存器-切换内核页表-分发中断至fastpath_reply_recv）-fastpath_reply_recv（合法性检查-消息收发-切换进程switchToThread_fp（切换页表setVSpaceRoot-设置进程set_current_thread）-保存内容fp_restore）
### 辅助线程：
获取ipcbuffer-获取endpoint-循环发送接收(不断调用call)  
call调用：trap（切换栈-保存寄存器-切换内核页表-分发中断至fastpath_call）-fastpath_call（合法性检查-消息收发-切换进程（切换页表-设置进程）-保存内容）
### 一次收发消息的线程交互
辅助线程-辅助线程call-陷入内核（切换页表1）-fastpath_call-退出内核（切换页表2）-主线程-主线程reply_recv-陷入内核（切换页表3）-fastpath_reply_recv-退出内核（切换页表4）-辅助线程
### 一次收发消息的线程交互(函数版)
辅助线程-trap.S-fastpath_call-主线程-trap.S-fastpath_reply_recv-辅助线程
## 汇编部分时间读取设计方案
位置：trap.S  
### 测试部分： 
1. 保存上下文（寄存器）
2. 切换页表
3. 中断分发
### 测试方案
在trap.S中s5、s6寄存器从未被使用，因此作为实验临时寄存器。  
为了测试开始保存寄存器的时间点，在保存寄存器开始时先保存s5寄存器。  
由于保存上下文的部分时间占比小，头尾测试法时间粒度过大，因而采用总时间减去其余时间的方法测试。  
### 测试流程：
1. 测出从开始保存寄存器到分发中断结束的总时间t0
2. 测出从开始保存寄存器到完成页表切换的时间t1
3. 测出页表切换的时间t2
4. 数据分析trap.S占用总时间为t0，保存寄存器占用时间为t1-t2，页表切换占用时间为t2，分发中断占用时间为t0-t1  

数据获取：在被测部分前后调用rdtime指令读取时间至寄存器，然后相减得到时间，并将结果写入某个寄存器，陷入内核后通过rust内嵌汇编函数读取寄存器的内容，并用debug宏输出
## fastpath函数设计方案
位置：fastpath.rs  
### 测试部分： 
1. 正确性检查
2. 数据结构设置
3. 进程切换（页表切换）
4. 消息拷贝
### 测试方案
使用read_time()函数测出前后时间相减后用debug宏输出，并在结尾求平均数输出。
## 实验数据（单位：cycle，测试方法：4096次通信后取平均）
### 汇编部分
原始数据：  
1. 从开始保存寄存器到分发中断结束的总时间t0：68
2. 测出从开始保存寄存器到完成页表切换的时间t1：61
3. 测出页表切换的时间t2：57

数据处理：
步骤|操作|计算方法|所占时间（单位cycle）|占比
-|-|-|-|-
1|保存寄存器|t1-t2|4|5.9%
2|页表切换|t2|57|83.8%
3|分发中断|t0-t1|7|10.3%
-|总时间|t0|68|100%

### fastpath_call
原始数据：  
1. 从进入call函数到完成所有操作的时间t0：73
2. 从进入call函数到完成正确性检查的时间t1：21
3. 从进入call函数完成数据结构设置的时间t2：24
4. 进程切换（页表切换）的时间t3：57
5. 从进入call函数完成进程切换的时间t4：73

数据处理：
步骤|操作|计算方法|所占时间|占比
-|-|-|-|-
1|正确性检查|t1|21|28.8%
2|数据结构设置|t2-t1|3|4.1%
3|进程切换（页表切换）|t4-t2|49|67.1%
4|消息拷贝|t0-t4|0|0%
-|总时间|t0|73|100%

### fastpath_reply_recv
原始数据：  
1. 从进入call函数到完成所有操作的时间t0：69
2. 从进入call函数到完成正确性检查的时间t1：17
3. 从进入call函数完成数据结构设置的时间t2：27
4. 进程切换（页表切换）的时间t3：53
5. 从进入call函数完成进程切换的时间t4：68

数据处理：
步骤|操作|计算方法|所占时间|占比
-|-|-|-|-
1|正确性检查|t1|17|24.6%
2|数据结构设置|t2-t1|10|14.5%
3|进程切换（页表切换）|t4-t2|41|59.4%
4|消息拷贝|t0-t4|1|1.5%
-|总时间|t0|69|100%

## 占比分析
### 用户态vs内核态
在一轮的消息收发中，时钟占比如下：
名称|时间（cycle）|占比
-|-|-
用户态代码|702|70.92%
内核代码|285|29.08%
总时间|980|100%

可以看出相比于内核态代码，用户态代码所占的时间更为突出。但经过验证用户态代码数量并不多，导致高时延的原因可能在于在rust中使用的代码包含了对C侧sel4代码的深度封装，导致了较高的递推时延。
### 内核态路径
在一轮的消息收发中包括2次trap陷入和1次fastpath_call()函数的运行以及一次fastpath_reply_recv()函数的运行：  
具体路径为：辅助线程-trap.S-fastpath_call-主线程-trap.S-fastpath_reply_recv-辅助线程  
步骤|操作|时间（cycle）|占比
-|-|-|-
1|特权级切换|-|-
2|保存辅助线程寄存器|4|1.40%
3|内核页表切换|57|20.00%
4|分发中断|7|2.46%
5|call的正确性检查|21|7.37%
6|call的数据结构设置|3|1.05%
7|call的进程切换（页表切换）|49|17.19%
8|call的消息拷贝|0|0%
9|中断返回|-|-
10|特权级切换|-|-
11|保存主线程线程寄存器|4|1.40%
12|内核页表切换|57|20.00%
13|分发中断|7|2.46%
14|reply的正确性检查|24|8.42%
15|reply的数据结构设置|10|3.51%
16|reply的进程切换（页表切换）|41|14.39%
17|reply的消息拷贝|1|0.35%
18|中断返回|-|-
-|正确性检查|45|15.79%
-|页表切换|204|71.58%
-|消息拷贝|1|0.35%
-|总时间|285|100%

分析数据可知：
1. 页表切换在内核路径中占用了绝大多数时钟周期。
2. fastpath函数中正确性检查和数据结构设置的时间不可忽略。
3. 在本次测试中消息拷贝的时间很短，原因在于，本次测试采用的消息大小只有1字节，而消息拷贝的实现形式是寄存器拷贝，速度较内存拷贝更快，因此时间可以忽略不计。

## 遇到的问题
1. 测试代码无法进入fastpath（已解决）：在root-task-demo的测试用例中消息设置不合理导致在fastpath的消息合法性检查中被驳回进入slowpath。
2. 内核时间占比过小，不合理（正在解决）：对项目结构的认识还有一定缺陷，在trap.S分发完中断后会调用c_handle_fastpath系列函数，在此函数中由于多核的存在需要等待内核锁（每次只能有一个核心在内核态，在CPU核心收到时钟中断的时候获取锁），这部分的时间开销未被统计，可能导致内核态的时间统计不完全。