# 2024/05/01
进展：
1. 完成论文大纲和时间安排并同步至仓库

向老师意见：
1. 对reL4的分析是必要的
2. 建议第六和七章合并，结论单独写。
3. 感觉时间安排还是比较紧的。建议优先形成第一稿，然后再进行完善。

陆老师意见：
1. 同意向老师的意见，第六章与第七章关于实验部分合并
2. 总结可以单开一章，是整篇论文的总结，做了什么，还有什么不足，进一步可做的工作

# 2024/05/01
进展：
1. 完成论文大纲和时间安排并同步至仓库
2. 完成异步系统调用CNodeCancelBadgedSends，待测试
3. 完成异步系统调用CNodeRevoke，待测试
4. 完成论文第一章：绪论

问题：
1. CNodeRotate需要的参数为9个，而现有的extend_msg支持的参数个数为8个，不满足要求
# 2024/04/30
讨论：
1. 维护notification（key：notification ptr）到(senderid, new_buffer)的映射，用于内核态，static
2. 在注册异步系统调用时维护
# 2024/04/28
进展：
1. 在用户态封装已完成系统调用的测例
2. 同步代码
3. 完成异步系统调用CNodeMint，待测试
4. 按照同步系统调用的方式对CNode系列系统调用的异步处理进行了封装
5. 完成异步系统调用CNodeMove，待测试
6. 完成异步系统调用CNodeMutate，待测试

问题：
1. （已解决：进行进一步封装，提高代码复用率）考虑将CNode系列函数进行进一步封装

提交：
1. git checkout -b cwh_dev
2. git status
3. git add .
4. git commit -m ""
5. git push origin cwh_dev:cwh_dev

# 2024/04/26
进展：
1. 对已完成的异步系统调用处理过程进行了进一步的封装，增加代码可读性
2. 将部分crate中的函数和mod改成pub公有
3. 完成异步系统调用UntypedRetype初步翻译
4. 完成对异步系统调用TCBBindNotification的测试工作
5. 完成异步系统调用CNodeDelete，待测试
6. 完成异步系统调用CNodeCopy，待测试

问题：
1. （已解决：征得学长允许）将部分crate中的函数和mod改成pub公有，不确定是否符合隔离要求

# 2024/04/25
进展：
1. 完成异步系统调用RISCVPageGetAddress，并测试通过
2. 新增异步系统调用参数设计文档
3. 完成异步系统调用TCBBindNotification，待测试
4. 完成异步系统调用TCBUnbindNotification，待测试

# 2024/04/24
进展：
1. 开始翻译异步系统调用RISCVPageGetAddress

问题：
1. (已解决：与当前协程有关的tcb应从参数中获取，否则调用get_current_thread获得的线程可能与之无关)在tcb的lookup_slot方法中调用resolve_address_bits时报错

# 2024/04/23
测试场景：
1. 

测试指标：
1. 陷入频率
2. 时延
3. 
# 2024/04/22
进展：
1. 新增异步系统调用PutString

问题：
1. 目前PutString只能打印ASCII码，长度限制为7个字符，需要再次详细制定extend_msg使用标准

系统调用流程：
1. 用户态陷入
2. slowpath进行合法性判断
3. 进入handleSyscall()分发
4. 进入handleInvocation()进行处理
5. 进入decodeInvocation()进行分发

# 2024/04/21
进展：
1. 提交代码：rust-root-task-demo、rel4_kernel、rust-sel4、kernel
2. 在内核态为async_syscall_handler新增有关sender_id的异常处理
3. 新增AsyncMessageLabel类标识异步系统调用，并为其与u32实现From trait，为async_syscall_handler新增系统调用Label分发逻辑
4. 翻译Putchar

问题：
1. 无

待翻译系统调用列表：
1. RISCVPageTableMap
2. RISCVPageTableUnmap
3. RISCVPageMap
4. RISCVPageUnmap
5. RISCVPageGetAddress
6. CNodeRevoke
7. CNodeDelete
8. CNodeCancelBadgedSends
9. CNodeCopy
10. CNodeMint
11. CNodeMove
12. CNodeMutate
13. CNodeRotate
14. UntypedRetype
15. TCBBindNotification
16. TCBUnbindNotification
17. Putchar
18. PutString
# 2024/04/18
进展：
1. 完成wake_syscall_handler系统调用的封装与调用
2. 用户态可以调用wake_syscall_handler系统调用陷入内核
3. 修改了slowpath中的逻辑错误
4. ！！！完成上述适配工作后，用户态可以发送系统调用唤醒内核处理协程，后续流程与先前一致
5. 在timer中限定内核处理携程在3号cpu上运行
6. 在tcb中新增字段asyncSysHandlerCid，并将handler的协程cid储存在此，以此进行调度

问题：
1. (已解决：不会，因为每个引用都是单独由指针生成的)get_current_thread可能导致同时借用问题？

代码提交：
1. rust-root-task-demo
2. rel4_kernel
3. rust-sel4
4. kernel
# 2024/04/17
进展：
1. 将内核态new_buffer.rs中的实现与用户态同步，根据实现变动对代码做了适配
2. 将内核态utils.rs中RingBuffer的实现与用户态同步，根据实现变动对代码做了适配
3. 修改内核态new_buffer.rs中IPCItemQueue的实现方法
4. ！！！完成上述适配工作后，用户态发送异步系统调用内核态可以正常接收，并且前后IPCItem中msg_info内容一致
5. 修改内核态注册发送端的逻辑错误（内核发送用户态中断共用uist，不同协程使用不同的offset），在uintc新增函数register_sender_async_syscall
6. 为用户态注册接收端
7. ！！！完成上述工作后，用户态接收协程可以被内核态唤醒并接收内核处理结果
8. 注册WakeSyscallHandler系统调用，并在用户态封装

问题：
1. （已解决：内核态与用户态ItemQueue实现不一致，用户态版本有更新，需要同步内核实现）内核态在async_syscall_handler中无法正常读取ItemQueue中的IPCItem
2. （已解决：放弃，修改读写实现为自旋锁）内核态new_buffer.rs中无法use sel4::r#yield
3. （已解决：忘记为用户态注册接收端）内核态async_syscall_handler()中发送完用户态中断无法唤醒用户态接受相应的协程
4. （已解决：问题消失了）在qemu模拟的过程中系统有死锁的概率

添加系统调用流程：
1. 在kernel/libsel4/include/api/syscall.xml中注册（修改xml后需要重新install）
2. 编译
3. 在rel4_kernel/build/libsel4/include/sel4/syscall.h中找到枚举值
4. 在slowpath里新建对应枚举值并作特殊判断

用户态调用系统调用：
1. 在reL4_kernel\build\cargo\build\riscv64imac-sel4\debug\build\sel4-sys-8887aaed297c6343\out\syscall_ids.rs中查看生成的枚举名
2. 在rust-root-task-demo/rust-sel4/crates/sel4/sys/src/syscalls/calls.rs中封装系统调用
3. 调用即可
# 2024/04/16
进展：
1. 同步kernel最新代码
2. 在async_syscall_test中调用runtime_init初始化运行时和调度器

问题：
1. （已解决：更新kernel）root-tast-demo中main.rs中recv_tcb.tcb_set_affinity(1)的后续语句无法执行（自查了代码，应该不是目前更新的代码的缘故）
2. （已解决：在生成前使用runtime_init初始化运行时，生成调度器）coroutine_spawn生成错误
# 2024/04/15
进展：
1. 同步rel4_kernel、rust-root-task-demo最新代码
2. 为用户态async_syscall_test()中的代码适配最新接口，并修复了无法通过编译的引用问题
3. 在内核中为注册异步系统调用Buffer同时注册内核的用户态中断发送端
4. 修改了uintc中的register_sender函数，新增了sender_id的返回值并做了适配
5. 修改内核态async_syscall_handler()，传入参数新增sender_id，并完成了封装中断发送流程的用户态中断发送函数send_async_syscall_uintr()

问题：
1. （已解决：需要定义一个系统调用执行操作，目前先在时钟中断中让协程一直运行以忽略此问题）用户态如何发送系统调用，具体为用户态如何知道CPU繁忙情况并唤醒对应的内核接收协程在空闲CPU上执行
2. （已解决：核间中断）协程与线程不同，无法被调度，如何让空闲CPU执行协程
3. （已解决：发送端还没注册，注册后直接传入协程即可，传入协程的还得有一个offset）内核处理协程中如何获取sender_id发送用户态中断
4. （已解决：更新kernel）root-tast-demo中main.rs中recv_tcb.tcb_set_affinity(1)的后续语句无法执行（自查了代码，应该不是目前更新的代码的缘故）

开发步骤：
1. 注册接收端（仿照异步IPC）并将sender_id传入协程
2. 仿照网卡驱动完成offset分配，传入协程
3. 新增系统调用，供用户态在发现内核协程不在线时使用，该系统调用需要寻找空闲核心执行协程并用到IPI
# 2024/04/14
进展：
1. 在rel4_kernel下task_manager中新增函数get_idle_cpu_index  

问题：
1. 用户态如何发送系统调用，具体为用户态如何知道CPU繁忙情况并唤醒对应的内核接收协程在空闲CPU上执行（需要定义一个系统调用执行操作？）
2. 协程与线程不同，无法被调度，如何让空闲CPU执行协程（内核接收协程是否也为此线程的部分，如果是，相当于一个线程的用户态和内核态在两个CPU上分别运行？）
3. 内核处理协程中如何获取sender_id发送用户态中断（通过tcb？tcb中维护了绑定的notification和IPCBuffer，猜测sender_id为IPCBuffer中的uintr_flag）
# 2024/04/13
进展：
1. 修改了root-task-demo中async_lib中seL4_Call_with_item的SEND_MAP映射错误

问题：
1. （需要定义一个系统调用执行操作？）用户态如何发送系统调用，具体为用户态如何知道CPU繁忙情况并唤醒对应的内核接受协程在空闲CPU上执行
2. （通过tcb？）内核处理协程中如何获取sender_id发送用户态中断
# 2024/03/18
完成同步IPC测试与数据分析
# 2024/03/17
阅读论文《L4 microkernels: The lessons from 20 years of research and deployment》并修改部分翻译内容
# 2024/03/16
# 2024/03/15
# 2024/03/14
测试同步IPC代码路径  
发现了由于消息设置不合理导致fastpath_mi_check阻断进入fastpath的问题，已解决  
调整了用户态的部分设置如object_allocator下的tcb.tcb_set_affinity(1)
# 2024/03/13
阅读论文《L4 microkernels: The lessons from 20 years of research and deployment》并修改部分翻译内容
# 2024/03/12
开组会
# 2024/03/11
阅读rel4源码  
阅读sel4介绍文档  
进行部分同步IPC测试  
考虑补充sel4介绍文档中reply_cap代理部分介绍
# 2024/03/10
阅读rel4源码  
阅读sel4介绍文档
进行部分同步IPC测试
# 2024/03/09
阅读rel4源码  
将帮助文档部署到gitbook
# 2024/03/08
阅读rel4源码  
完成rel4 rust侧代码环境配置  
进一步完善帮助文档
# 2024/03/07
阅读rel4源码  
完成帮助文档markdown版本撰写
# 2024/03/05
完成rel4基本环境配置
# 2024/03/02
配置WSL以替换Ubuntu虚拟机  
完成seL4环境配置  
完成仓库搭建  
# 2024/03/01
在Ubuntu虚拟机上initial repo  
在Ubuntu虚拟机上配置seL4环境  