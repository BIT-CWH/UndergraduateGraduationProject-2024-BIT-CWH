# L4 microkernels: The lessons from 20 years of research and deployment
# 摘要
本文研究了从原始L4到最新一代L4内核的设计和实现的演变，总结了这20年中关于微内核设计和实现的经验教训。本文特别关注seL4，它把L4模型推得最远，并且是第一个对其实现进行完整形式验证以及对最坏情况执行时间进行合理分析的操作系统内核。尽管微内核在发展中发生了很大变化，但最小性、通用性和IPC性能仍然是设计和实现的主要驱动力。   
# 介绍
20 年前，Liedtke [1993a] 用他的 L4 内核证明了微内核 IPC 可以很快，比当代微内核快 10-20 倍。  
微内核最小化了内核提供的功能：内核提供了一组通用机制，而用户模式服务器则实现了实际的操作系统（OS）服务[Brinch Hansen 1970;Levin 等人，1975 年]。应用程序代码通过进程间通信 （IPC） 机制（通常是消息传递）与服务器通信来获取系统服务。因此，IPC 处于任何服务调用的关键路径上，低 IPC 成本至关重要。  
到 1990 年代初，IPC 性能已成为微内核的致命弱点：单向消息的成本过高，约为 100 μs，导致了将核心服务移回内核的趋势 [Condict et al. 1994]。也有人认为，高IPC成本是基于微内核的系统结构的固有的结果[Chen和Bershad 1993]。  
在这种情况下，Liedtke所展示的IPC成本的量级改进是相当显着的。随后，他讨论了L4的理念和机制 [Liedtke 1995， 1996]，在L4上演示了半虚拟化的 Linux，开销只有百分之几 [Hartig et al. ̈ 1997]，在数十亿个移动设备和安全关键系统中部署 L4 内核;最后，L4 对其他研究系统也有很强的影响。  
本文中研究了自 1990 年代中期以来 L4 的发展。具体来说，研究了现代L4内核的运作机制与 Liedtke 的原始设计和实现规则有何关系，以及他的哪些微内核“基本要素”通过了时间的考验。本文还研究了过去的经验教训如何影响最新一代 L4 微内核的设计，例如 seL4 [Klein et al. 2009]，并指出了其他当前 L4 版本在哪些方面做出了不同的设计决策。

# 背景
Background部分介绍了L4家族群  
# 微内核设计
## IPC
### 同步IPC 
最初的 L4 支持同步（交会式）IPC 作为唯一的通信、同步和信号机制。同步 IPC 避免了内核中的缓冲以及与之相关的管理和复制成本。在其最简单的版本（在寄存器中传递的短消息）中，它只不过是一个上下文开关，使消息寄存器保持不变。  
这种模型的显着缺点：它强制在本来简单的系统进行多线程设计，导致同步具有复杂性。例如，系统缺乏类似于UNIX select（）的功能，需要每个中断源使用单独的线程，而单线程服务器又无法同时等待客户端请求和中断。  
此外，同步消息传递显然是跨处理器内核同步活动的错误方式。在单个处理器上，线程之间的通信最终需要进行上下文切换，将其与通信相结合可以最大程度地减少开销。因此，经典的 L4 IPC 模型是绕过调度程序的用户控制的上下文切换模型。  
L4-embedded中通过添加Notification（一种简单的、非阻塞的信令机制）解决了这个问题。后来，seL4的Notification objetc改进了这个模型：Notification包含一组标志，即Notification word。对Notification object的信号操作在不阻塞的情况下设置标志的子集。可以通过轮询或等待（阻塞）信号来检查Notification word。Notification不是异步IPC，而是同步与通信的解耦，对于有效利用硬件的并发性至关重要。  
总之，与大多数其他L4内核一样，seL4 保留了同步IPC的模型，但通过类似信号量的Notification对其进行了增强。OKL4 已经完全放弃了同步 IPC，取而代之的是虚拟 IRQ（类似于通知）。NOVA通过计数信号量增强了同步IPC [Steinberg和Kauer 2010]，而Fiasco.OC也通过虚拟IRQ增强了同步IPC。
### IPC消息结构
#### 短消息
原始的消息传递采用消息寄存器：内核始终从发送方的上下文启动 IPC，并在不更改消息寄存器的情况下切换到接收方的上下文。缺点是依赖于体系结构且（尤其是在 x86 上）支持消息的大小较小，且随着ABI的参数更改而变动。  
Pistachio引入了虚拟消息寄存器的概念：将其中一些虚拟寄存器映射到物理寄存器，其余的则包含每个线程地址空间的固定部分中。储存在固定部分的方式可确保访问按照类似访问寄存器的方式进行，不会出现页面错误。seL4 和 Fiasco.OC 继续使用这种方法。此模型优势在于，虚拟消息寄存器大大提高了跨架构的可移植性。此外，它们还减少了中等大小的邮件超过物理寄存器数量的性能损失。但随着时间的流逝，通过寄存器的消息传输优势不再，因为上下文切换的成本主导了 IPC 性能。 
#### 长消息 
在原始 L4 中，“长”消息可以在单个 IPC 调用中指定多个缓冲区，以摊销硬件和上下文切换成本。长消息可以通过单个副本传递：在发送方的上下文中发起，内核在接收方的地址空间中设置一个临时映射窗口，覆盖为消息，并直接复制到接收方。  
这可能导致在源地址空间或目标地址空间中的复制期间触发页面错误，这需要内核处理嵌套异常。此外，处理此类异常需要调用用户级页面错误处理程序。必须在内核仍在处理 IPC 系统调用时调用处理程序，但调用必须假装错误发生在正常的用户模式执行期间。返回时，必须重新建立原始系统调用上下文。结果是内核的复杂性大大增加，许多棘手的极端情况可能会在实现中出现错误
虽然长消息IPC提供了在低开销的情况下无法实现的功能，但在实践中很少使用：批量数据传输首选共享缓冲区，而虚拟寄存器的引入也增加了支持的小型消息的大小。  
对于 seL4 来说，有更充分的理由不支持长消息：形式化验证方法明确避免了内核中的任何并发性[Klein et al. 2009]，而嵌套异常引入了一定程度的并发性。嵌套异常难以进行形式化验证，虽然可以通过额外检查来避免上述页面错误，从而避免嵌套异常，但是十分复杂，且且降低内核性能。
### IPC目的地
原始L4将线程作为IPC操作的目标。其动机是避免与间接水平相关的缓存和TLB污染。该模型要求线程ID是唯一标识符。但该模型有一个缺点，即信息隐藏性差。多线程服务器必须向客户端公开其内部结构，以分散客户端负载，或者使用网关线程，这可能会成为瓶颈，并会带来额外的通信和同步开销。  
受EROS[Shapiro et al. 1999]的影响，seL4和Fiasco.OC [Lackorzynski 和 Warg 2009]）采用IPC端点作为IPC目的地。seL4端点本质上是端口：待处理发送方或接收方队列现在是一个单独的内核对象，而不是接收方线程控制块TCB的一部分。与 Mach 端口 [Accetta et al. 1986] 不同，IPC端点不提供任何缓冲。  
为了帮助服务器识别客户端，而不需要每个客户端的端点，seL4提供了徽章功能。具有不同徽章但派生自同一原始功能的功能指向相同的端点对象，但在调用时将徽章作为发送方的标识传递给接收方。
### IPC超时
阻塞IPC机制为拒绝服务（DOS）攻击创造了机会。为了防止此类攻击，原始L4中的IPC操作设置了超时。超时值以浮点格式编码，支持从一毫秒到周的零值、无穷大和有限值。它们增加了管理唤醒列表的复杂性。然而，设置超时作为DOS防御措施几乎没有用处。在系统中，没有理论甚至没有好的启发式方法来选择超时值；在实践中，只使用了值零和无穷大：客户端以无限超时发送和接收，而服务器以无限超时等待请求。  
在放弃了长IPC之后，在L4-embedded中用一个支持轮询（零超时）或阻塞（无限超时）选择的标志替换了超时。只需要两个标志，一个用于发送，一个用于接收阶段。sel4也采用此模型。而完全异步模型（例如 OKL4 的模型）与超时不兼容，并且没有需要超时的 DOS 问题。  
此外，超时也可用于通过等待来自不存在线程的消息来定时睡眠。  
### 通信控制
在最初的L4中，内核将发送方的ID传递给接收方。这允许服务器通过忽略不需要的消息来实现一种自由访问控制形式。但是服务器可能会受到恶意客户端的消息轰炸，接收并检查此类消息有一定时间开销。因此，此类消息可能构成 DOS 攻击，只有通过内核支持才能避免，内核支持首先可以防止发送不需要的消息 [Liedtke et al. 1997b]。强制性访问控制策略还需要一种用于调解和授权通信的机制。  
最初的L4通过一种称为部落和酋长的机制提供了这一点：进程按照“部落”的等级制度进行组织，每个部落都有一个指定的“酋长”。在部落内部，所有消息都是自由传输的，内核保证了消息的完整性。但是，跨越部落边界的信息，无论是传出还是传入，都会被重定向到部落的酋长。该机制还支持对不受信任的子系统进行限制 [Lipner 1975]。  
Liedtke [1995]认为，部落和酋长模型在每个IPC操作中只增加了两个周期，因为部落ID被编码在线程ID中以便快速比较。但是，低开销仅适用于可以直接通信的情况。一旦邮件被重定向，每个这样的重定向都会将两条邮件添加到（逻辑上）单个往返 IPC，这是一个巨大的开销。此外，严格的线程层次结构在实践中是笨拙的。对于强制访问控制，该模型很快恶化为每个进程为一个酋长。由于这些缺点，许多L4内核实现没有实现部落和酋长，或者在构建时禁用了该功能，但这意味着无法控制 IPC。该问题最终通过在Endpoint上灵活地以Capability为中介的访问控制得到解决。  
## 用户级设备驱动
最小性原则的一个最重要的结果，并且也许是 L4（或者更确切地说，它的前身 L3 [Liedtke et al. 1991]）最具争议的功能，是使所有设备驱动程序都成为用户级进程。作为驱动程序，进入内核将消除任何保证，并且目前在现实世界的系统中验证大量驱动程序代码是遥不可及的。  
但少数驱动程序最好仍保留在内核中。在现代 L4 内核中，这通常指一个计时器驱动程序（用于在用户时间片结束时抢占用户进程）以及中断控制器的驱动程序（将中断安全地分发到用户级进程）。  
用户级驱动程序模型与模块中断紧密耦合为 IPC 消息，内核将这些消息发送到驱动程序。多年来，模型的细节（来自虚拟线程的 IPC 与上调）以及关联和确认协议发生了变化（一次又一次地更改），但一般方法仍然适用。  
最显著的变化是从IPC转向Notification作为中断传递的机制。这里的主要驱动因素是实现简化，因为消息传递需要模拟虚拟内核线程作为中断 IPC 的来源，而发送信号的Notification与硬件的功能自然匹配。  
用户级驱动程序受益于虚拟化驱动的硬件改进。I/O 内存管理单元 （IOMMU） 已为驱动程序启用安全直通设备访问。用户级驱动程序也受益于硬件开发，这些硬件开发减少了中断开销，特别是现代网络接口上的中断合并支持。  
当然，用户级驱动程序现在已经成为主流， Linux、Windows 和 MacOS 上都支持这种方式（尽管不被鼓励）。这些系统的开销通常高于IPC高度优化的 L4。但我们在过去就已经证明，即使在 Linux 上也可以实现低开销，至少在上下文切换友好的硬件上是这样 [Leslie et al. 2005a]。
## 资源管理
最初的 L4 的资源管理，就像它的通信控制方法一样，很大程度上是基于进程层次结构的。这适用于管理进程和虚拟内存。层次结构是管理和恢复资源的有效方法，它提供了约束子系统的模型：系统机制将子级的权限限制为其父级的子集。代价是管理较为死板。此外，层次结构是一种策略形式，因此与微内核的原则（策略与机制分离，内核提供机制）不匹配。  
Capabilities可以提供一种摆脱层次结构限制的方法，这是所有现代 L4 内核采用基于Capabilities的访问控制的几个原因之一。在这里，我们研究了原始 L4 模型中出现的最重要的资源管理问题，以及我们现在如何处理这些问题。
### 进程层次结构
L4 没有最高级（first-class）进程概念，它采用一个更高级别的抽象，由一个地址空间（由页表表示）和许多关联的线程组成。这些会消耗内核资源，并且未经检查地分配 TCB 和页表很容易导致拒绝服务。最初的 L4 通过进程层次结构来处理这个问题：“Task IDs”本质上是地址空间上的Capabilities，允许创建和删除。  
这些ID数量有限，由内核分发且先到先得。它们可以被委派，但只能在层次结构中向上或向下委派。它们还与用于 IPC 控制的线程层次结构密切相关。在典型的设置中，初始用户进程（initial user process）将在创建任何其他进程之前获取所有Task ID。  
也许不足为奇的是，这种强加特定政策的模式被证明是僵化和具有限制性的，它最终被成熟的Capability机制所取代。
### 递归页面映射
原始 L4 将物理内存帧的权限与现有页面映射绑定在一起。如果在其地址空间中具有对一个页面的有效的映射，则进程有权将该页面映射到另一个地址空间。进程可以授权别的进程其中一个它持有的页面（而非映射），该页面及其任何权限将从授予者那里删除。映射（而非授权）可以通过取消映射操作撤销。进程的地址空间创建时为空，并使用映射基元进行填充。  
递归映射模型基于在原始地址空间 σ0 中，该地址空间接收内核启动后剩余的所有空闲帧的恒等映射。σ0 是在启动时创建的，所属于所有进程的页面错误处理程序。它将它的页面映射到第一个请求该页面的进程，该进程通过地址空间中的缺页错误来请求。  
请注意，虽然 L4 内存模型创建了源自每个页帧的映射层次结构，但它不会强制使用地址空间的分层视图：映射是通过 IPC 建立的，类似于通过 IPC 消息传输capability。一个进程可以将它的页面映射到它被允许向其发送IPC的任何其他进程，前提是接收方同意接收映射。与 Mach 相比，L4 没有内存对象语义，只有低级地址空间管理机制，这些机制更接近 Mach 的内核内 pmap 接口，而不是其用户可见的内存对象抽象 [Rashid et al. 1988]。内存对象、写入时复制和影子链都是用户级创建的抽象或实现方法。   
递归映射模型在概念上简单而优雅，Liedtke 显然对此感到自豪：它在许多文章中都占有重要地位，包括第一篇文章 [Liedtke 1993a]，以及他的所有演讲。然而，经验表明，这个模型存在着明显的缺点。  
为了支持以页面为粒度的吊销，递归地址空间模型需要以映射数据库的形式进行大量簿记。此外，L4 内存模型的通用性允许两个恶意串通好的进程通过递归地将同一帧映射到彼此地址空间中的不同页面来迫使内核消耗大量内存，这是一种潜在的 DOS 攻击，尤其是在 64 位硬件上，这只能通过控制 IPC 来防止（通过可怕的氏族酋长， 参见第 3.2.5 节）。  
L4-embedded 删除了递归映射模型，因为在实际使用中，即使没有恶意进程，映射数据库也会消耗 25% 到 50% 的内核内存。我们用一个更能反应硬件的模型取代了它，其中映射总是源于一系列物理内存帧范围。  
这种方法的代价是丢失对内存的细粒度委派和撤销（而不是通过对页表进行暴力扫描）。因此作者认为它只能暂时止痛。OKL4 在一定程度上扩展了这个最小模型，但没有实现原始模型的通用性和细粒度控制。  
当然，在基于Capability的系统中，使用标准获取-授予模型的变体[Lipton和Snyder 1977]，可以很容易地实现映射控制。这就是 seL4 提供的：映射权是通过指向物理页帧的capability传达的，而不是通过访问由该物理页帧支持的虚拟页面来传达的，因此 seL4 的模型不是递归的。即使具有页帧capability，映射也会受到用于记录映射的显式内核内存模型的严格限制，如第 3.4.3 节所述。  
Xen 提供了一个有趣的比较点 [Fraser et al. 2004]。授权表允许创建（基于拥有有效映射）的帧capability，该capability可以传递到另一个域以建立共享映射。最近的一项提案扩展了授权表，以允许撤销页帧 [Ram 等人，2010 年]。内存映射原语的语义与 seL4 的语义大致相似，但缺少页面错误的传播。在 Xen 的案例中，支持细粒度委派和吊销的开销仅在共享实例中存在。  
NOVA 和 Fiasco.OC 都保留了递归地址空间模型，其映射权限由拥有有效映射来确定。因此无法限制映射，从而无法限制簿记分配的问题由 Fiasco.OC 中的每个任务拥有内核内存池解决。  
现有的细粒度委派和吊销的 L4 地址空间模型代表了机制的通用性和最小性与可能更节省空间的域特定方法之间的不同权衡。  
总之，一些 L4 内核保留了递归地址空间构造的模型，而 seL4 和 OKL4 则从页帧发起映射。只有 seL4 提供页面访问的细粒度委派。
### 内核内存
虽然Capabilities为委派提供了一个简洁而优雅的模型，但它们本身并不能解决资源管理问题。具有映射权限的恶意线程仍然可以使用它来创建大量映射，迫使内核消耗大量内存来存储元数据来对系统进行潜在的DOS攻击。  
传统 L4 内核有一个固定大小的堆，内核从中为其数据结构分配内存。最初的 L4 有一个称为 σ1 的内核寻呼机，内核可以通过它从用户空间请求额外的内存。这并不能解决恶意（或有缺陷）的用户代码不合理的内存消耗的问题，且只会转移问题。因此，大多数 L4 内核不支持 σ1。  
大多数其他操作系统都存在的基本问题是共享内核堆对用户进程的隔离存在不足。因此，一个完美的方法必须能够提供完全隔离。根本问题是，即使在权限由capabilities表示的系统中，如果Capability机制之外存在资源（如内核内存），也无法推断系统的安全状态。  
将内存作为用户级内容缓存进行管理的内核们只能部分解决此问题。虽然基于缓存的方法消除了基于耗尽内存的 DOS 攻击的机会，但它们无法实现内核内存的严格隔离。严格隔离是功能隔离或实时系统的先决条件，并且可能会引入侧信道。  
Liedtke et al. [1997b] 研究了这个问题，并提出了一个进程一个内核堆的方案以及一种在内核内存耗尽时向内核捐赠额外内存的机制。NOVA、Fiasco 和 OKL4 都采用了这种方法的变体。一个进程的一个内核堆的方案通过消除对分配的控制来简化用户级别，代价是放弃了在不破坏进程的情况下撤销分配的能力，以及直接推断已分配内存的能力，而不仅仅是限制它。社区仍在探索在这方面的权衡。  
seL4 采取了截然不同的方法：它用于管理内核内存的模型是 seL4 对操作系统设计的主要贡献。出于对资源使用和隔离进行推断的愿望，除了内核用于启动所使用的大小固定的内存，包括其严格绑定的堆栈，作者将所有内核内存都置于capabilities传递的权限之下。具体来说，seL4 完全删除了内核堆，并为用户空间提供了一种在内核分配数据结构时识别被授权的内核内存的机制。这个方案的副产物是减少了内核的大小和复杂性，这对于验证而言是一个主要好处。  
问题的关键是使所有内核对象显式化，并受基于capabilities的访问控制。这种方法的灵感来自基于硬件的capability系统，尤其是 CAP [Needham and Walker 1977]，其中被硬件翻译的capabilities直接指向内存。HiStar [Zeldovich et al. 2011] 也使所有内核对象显式化，但它采用缓存方法来进行内存管理。  
当然，用户可见的内核对象并不意味着对内核对象有权限的进程可以直接读取或写入它。对应Capability提供调用特定对象的部分方法的权限，其中包括销毁对象（对象一旦创建，大小永远不会改变）。至关重要的是，内核对象类型包括未使用的内存，在 seL4 中称为 Untyped，可用于创建其他对象。  
具体来说，在 Untyped 上唯一可能的操作是将其部分retype为某个对象类型。新对象与原始 Untyped 的关系记录在Capability派生树中，该树还记录其他类型的capability派生，例如仅具有低级权限的capability副本。一旦某些 Untyped 被retype，对原始 Untyped 的（对应部分）的唯一可能的操作是撤消派生对象（见下文）。
Retype是在 seL4 中创建对象的唯一方法。因此，通过限制对 Untyped 内存的访问，系统可以控制资源分配。Retype方法还可以生成较小的 Untyped 对象，然后这些对象后续可以被单独管理，这是委派资源管理的关键。从 Untyped 派生还确保了内核的完整性，即没有两个typed对象是空间上重叠的。  
表 III 给出了完整的 seL4 对象类型集及其在 32 位 ARM 处理器中的使用，在 x86 结构中也非常相似。用户空间只能直接访问（加载/存储/获取）与Frame关联的内存。而通过将Frame Capability插入Page Table，Frame 被映射到其地址空间。
对象|描述
-|-
TCB|进程控制块
Cnode|Capability存储
Endpoint|用于IPC的类似于端口的会合对象
Notification|用于代表二进制信号的标志的集合
Page Directory|ARM虚拟内存的Top-level页表
Page Table|ARM虚拟内存的Leaf页表
Frame|大小为4KB、64KB、1MB或16MB的，可以被页表用于映射形成虚拟内存的对象
Untyped Memory|大小为2的倍数的一块物理内存区，其他内核对象可通过从其分配
按上述原理发展出的模型具有以下属性：
1. 显式授予所有权限（通过能力）。
2. 数据访问和权限可以受到限制。
3. 内核对于自己的数据结构，包括物理内存的消耗，都遵循分配给应用程序的权限。
4. 每个内核对象都可以独立于任何其他内核对象进行回收。
5. 所有操作都在“短”时间内执行或抢占（对象大小不大于页面的恒定或线性）。  
属性 1-3 确保可以对系统资源和安全性进行推断。特别是属性 3 对于正式地证明内核确保完整性、权限限制和机密性的能力至关重要 [Sewell 等人，2011 年;Murray 等人，2013 年]。属性 5 确保所有内核操作都具有低的有限延迟，因此支持将其用于硬实时系统 [Blackham 等人，2011 年]。内核中有一个长时间运行的操作——即Capability吊销，它需要抢占点（Preempting point）。这些抢占点可确保内核处于一致状态，也确保内核已取得进展，也可检查挂起的中断。如果存在挂起的中断，则内核将返回 usermode 以重新启动系统调用，从而确保中断被首先处理。重新启动的系统调用将继续执行上次尝试已停止的拆解工作。  
属性 4 确保内核完整性。任何合法capability的持有者都可以随时回收对象，这使得原始的 Untyped 对象可再次用于创建对象。例如，页表内存可以在不销毁相应的地址空间的情况下被回收。这要求内核能够检测并取消对正在回收的对象的任何引用。  
Capability派生树有助于满足这一要求。内存对象通过在树的上游的 Untyped 对象上调用 revoke() 方法被撤销；这将删除指向从该 Untyped 派生的所有对象的所有Capability。删除内存对象的最后一个Capability时，对象本身将被删除。这将删除此内核对象可能与其他对象具有的任何内核内依赖关系，从而使其可供重用。删除最后一个Capability的行为很容易检测，因为它会清除Capability树中指向特定内存位置的最后一个叶节点。  
吊销需要用户级别的簿记，以便将Untyped Capabilities与内核对象相关联，通常在用户级别定义的、更高级别抽象（如进程）的粒度上进行关联。Untyped 的精确语义及其与用户级簿记的关系仍在探索中。  
新功能：在 seL4 中对内核内存进行用户级控制，在 Fiasco.OC 中对内核内存配额进行控制。
### 时间
除了内存之外，系统中必须共享的另一个关键资源是 CPU。与内存不同，内存可以细分并在多个进程之间同时有效共享，而 CPU 一次只能由单个线程使用，因此必须进行时间多路复用。  
所有版本的 L4 都通过固定策略调度程序（可在 Fiasco.OC 中插入）实现这种多路复用。尽管违背了策略自由的核心微内核原则，最初的 L4 调度模型——硬优先级轮询仍然存在。过去所有将调度策略移出到用户级别的尝试都失败了，通常是由于无法忍受的开销，或者不完整或特定于某个域。  
特别是专注于实时问题的德累斯顿小组，对时间问题进行了广泛的实验，包括绝对超时（参见第 3.2.4 节）。他们还探索了几种调度方法，以及适用于实时和分析的基于 L4 的实时系统的系统结构 [Hartig 和 Roitzsch ̈ 2006]。  
虽然能够解决一些具体问题，但德累斯顿没有发明出一种无策略的通用机制，Fiasco.OC基本上恢复了传统的L4模式。最近一个关于调度上下文的提案允许将基于优先级的分层调度映射到单个优先级调度程序上 [Lackorzynski 等人，2012 年]，但仅在遗留的 Fiasco 内核（在引入功能之前的内核）中实现，因为它不适用于 IPC 端点提供的间接。  
有人可能会争辩说，适用于所有目的的单一通用内核的概念可能不像以前那样重要;现在我们已经习惯了环境插件。然而，seL4 的形式化验证对改变内核产生了强大的抑制作用，因为它强烈地强化了为所有使用场景提供单一平台的愿望，即通用性。因此，以无政策的方式处理时间是一如既往的可取。  
未解决：对 CPU tim 进行有原则的无策略控制  
# 微内核实现
Liedtke [1993a] 列举了一组设计决策和实现技巧，这些技巧有助于在原始 i486 版本中加快 IPC，尽管其中一些有过早优化的味道。  
有些已经提到过，例如现已过时的长IPC中使用的临时映射窗口。其他的则是没有争议的，例如单个系统调用中的发送-接收组合：用于类似 RPC 调用的客户端式调用和服务器式应答和等待。我们将更详细地讨论其余的，包括一些传统的 L4 实现方法，这些方法很少被宣传，但长期以来在社区中被认为是理所当然的。
## 严格的进程导向和虚拟TCB阵列


# 上下文切换

# 结论