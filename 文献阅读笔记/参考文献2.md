# L4 microkernels: The lessons from 20 years of research and deployment
# 摘要
本文研究了从原始L4到最新一代L4内核的设计和实现的演变，总结了这20年中关于微内核设计和实现的经验教训。本文特别关注seL4，它把L4模型推得最远，并且是第一个对其实现进行完整形式验证以及对最坏情况执行时间进行合理分析的操作系统内核。尽管微内核在发展中发生了很大变化，但最小性、通用性和IPC性能仍然是设计和实现的主要驱动力。   
# 介绍
20 年前，Liedtke [1993a] 用他的 L4 内核证明了微内核 IPC 可以很快，比当代微内核快 10-20 倍。  
微内核最小化了内核提供的功能：内核提供了一组通用机制，而用户模式服务器则实现了实际的操作系统（OS）服务[Brinch Hansen 1970;Levin 等人，1975 年]。应用程序代码通过进程间通信 （IPC） 机制（通常是消息传递）与服务器通信来获取系统服务。因此，IPC 处于任何服务调用的关键路径上，低 IPC 成本至关重要。  
到 1990 年代初，IPC 性能已成为微内核的致命弱点：单向消息的成本过高，约为 100 μs，导致了将核心服务移回内核的趋势 [Condict et al. 1994]。也有人认为，高IPC成本是基于微内核的系统结构的固有的结果[Chen和Bershad 1993]。  
在这种情况下，Liedtke所展示的IPC成本的量级改进是相当显着的。随后，他讨论了L4的理念和机制 [Liedtke 1995， 1996]，在L4上演示了半虚拟化的 Linux，开销只有百分之几 [Hartig et al. ̈ 1997]，在数十亿个移动设备和安全关键系统中部署 L4 内核;最后，L4 对其他研究系统也有很强的影响。  
本文中研究了自 1990 年代中期以来 L4 的发展。具体来说，研究了现代L4内核的运作机制与 Liedtke 的原始设计和实现规则有何关系，以及他的哪些微内核“基本要素”通过了时间的考验。本文还研究了过去的经验教训如何影响最新一代 L4 微内核的设计，例如 seL4 [Klein et al. 2009]，并指出了其他当前 L4 版本在哪些方面做出了不同的设计决策。

# 背景
Background部分介绍了L4家族群  
# IPC（细读）
## 同步IPC 
最初的 L4 支持同步（交会式）IPC 作为唯一的通信、同步和信号机制。同步 IPC 避免了内核中的缓冲以及与之相关的管理和复制成本。在其最简单的版本（在寄存器中传递的短消息）中，它只不过是一个上下文开关，使消息寄存器保持不变。  
这种模型的显着缺点：它强制在本来简单的系统进行多线程设计，导致同步具有复杂性。例如，系统缺乏类似于UNIX select（）的功能，需要每个中断源使用单独的线程，而单线程服务器又无法同时等待客户端请求和中断。  
此外，同步消息传递显然是跨处理器内核同步活动的错误方式。在单个处理器上，线程之间的通信最终需要进行上下文切换，将其与通信相结合可以最大程度地减少开销。因此，经典的 L4 IPC 模型是绕过调度程序的用户控制的上下文切换模型。  
L4-embedded中通过添加Notification（一种简单的、非阻塞的信令机制）解决了这个问题。后来，seL4的Notification objetc改进了这个模型：Notification包含一组标志，即Notification word。对Notification object的信号操作在不阻塞的情况下设置标志的子集。可以通过轮询或等待（阻塞）信号来检查Notification word。Notification不是异步IPC，而是同步与通信的解耦，对于有效利用硬件的并发性至关重要。  
总之，与大多数其他L4内核一样，seL4 保留了同步IPC的模型，但通过类似信号量的Notification对其进行了增强。OKL4 已经完全放弃了同步 IPC，取而代之的是虚拟 IRQ（类似于通知）。NOVA通过计数信号量增强了同步IPC [Steinberg和Kauer 2010]，而Fiasco.OC也通过虚拟IRQ增强了同步IPC。
## IPC消息结构
### 短消息
原始的消息传递采用消息寄存器：内核始终从发送方的上下文启动 IPC，并在不更改消息寄存器的情况下切换到接收方的上下文。缺点是依赖于体系结构且（尤其是在 x86 上）支持消息的大小较小，且随着ABI的参数更改而变动。  
Pistachio引入了虚拟消息寄存器的概念：将其中一些虚拟寄存器映射到物理寄存器，其余的则包含每个线程地址空间的固定部分中。储存在固定部分的方式可确保访问按照类似访问寄存器的方式进行，不会出现页面错误。seL4 和 Fiasco.OC 继续使用这种方法。此模型优势在于，虚拟消息寄存器大大提高了跨架构的可移植性。此外，它们还减少了中等大小的邮件超过物理寄存器数量的性能损失。但随着时间的流逝，通过寄存器的消息传输优势不再，因为上下文切换的成本主导了 IPC 性能。 
### 长消息 
在原始 L4 中，“长”消息可以在单个 IPC 调用中指定多个缓冲区，以摊销硬件和上下文切换成本。长消息可以通过单个副本传递：在发送方的上下文中发起，内核在接收方的地址空间中设置一个临时映射窗口，覆盖为消息，并直接复制到接收方。  
这可能导致在源地址空间或目标地址空间中的复制期间触发页面错误，这需要内核处理嵌套异常。此外，处理此类异常需要调用用户级页面错误处理程序。必须在内核仍在处理 IPC 系统调用时调用处理程序，但调用必须假装错误发生在正常的用户模式执行期间。返回时，必须重新建立原始系统调用上下文。结果是内核的复杂性大大增加，许多棘手的极端情况可能会在实现中出现错误
虽然长消息IPC提供了在低开销的情况下无法实现的功能，但在实践中很少使用：批量数据传输首选共享缓冲区，而虚拟寄存器的引入也增加了支持的小型消息的大小。  
对于 seL4 来说，有更充分的理由不支持长消息：形式化验证方法明确避免了内核中的任何并发性[Klein et al. 2009]，而嵌套异常引入了一定程度的并发性。嵌套异常难以进行形式化验证，虽然可以通过额外检查来避免上述页面错误，从而避免嵌套异常，但是十分复杂，且且降低内核性能。
## IPC目的地
原始L4将线程作为IPC操作的目标。其动机是避免与间接水平相关的缓存和TLB污染。该模型要求线程ID是唯一标识符。但该模型有一个缺点，即信息隐藏性差。多线程服务器必须向客户端公开其内部结构，以分散客户端负载，或者使用网关线程，这可能会成为瓶颈，并会带来额外的通信和同步开销。  
受EROS[Shapiro et al. 1999]的影响，seL4和Fiasco.OC [Lackorzynski 和 Warg 2009]）采用IPC端点作为IPC目的地。seL4端点本质上是端口：待处理发送方或接收方队列现在是一个单独的内核对象，而不是接收方线程控制块TCB的一部分。与 Mach 端口 [Accetta et al. 1986] 不同，IPC端点不提供任何缓冲。  
为了帮助服务器识别客户端，而不需要每个客户端的端点，seL4提供了徽章功能。具有不同徽章但派生自同一原始功能的功能指向相同的端点对象，但在调用时将徽章作为发送方的标识传递给接收方。
## IPC超时
阻塞IPC机制为拒绝服务（DOS）攻击创造了机会。为了防止此类攻击，原始L4中的IPC操作设置了超时。超时值以浮点格式编码，支持从一毫秒到周的零值、无穷大和有限值。它们增加了管理唤醒列表的复杂性。然而，设置超时作为DOS防御措施几乎没有用处。在系统中，没有理论甚至没有好的启发式方法来选择超时值；在实践中，只使用了值零和无穷大：客户端以无限超时发送和接收，而服务器以无限超时等待请求。  
在放弃了长IPC之后，在L4-embedded中用一个支持轮询（零超时）或阻塞（无限超时）选择的标志替换了超时。只需要两个标志，一个用于发送，一个用于接收阶段。sel4也采用此模型。而完全异步模型（例如 OKL4 的模型）与超时不兼容，并且没有需要超时的 DOS 问题。  
此外，超时也可用于通过等待来自不存在线程的消息来定时睡眠。  
## 通信控制
在最初的L4中，内核将发送方的ID传递给接收方。这允许服务器通过忽略不需要的消息来实现一种自由访问控制形式。但是服务器可能会受到恶意客户端的消息轰炸，接收并检查此类消息有一定时间开销。因此，此类消息可能构成 DOS 攻击，只有通过内核支持才能避免，内核支持首先可以防止发送不需要的消息 [Liedtke et al. 1997b]。强制性访问控制策略还需要一种用于调解和授权通信的机制。  
最初的L4通过一种称为部落和酋长的机制提供了这一点：流程按照“部落”的等级制度进行组织，每个部落都有一个指定的“酋长”。在部落内部，所有消息都是自由传输的，内核保证了消息的完整性。但是，跨越部落边界的信息，无论是传出还是传入，都会被重定向到部落的酋长。该机制还支持对不受信任的子系统进行限制 [Lipner 1975]。（类似于外部网关协议）  
Liedtke [1995]认为，部落和酋长模型在每个IPC操作中只增加了两个周期，因为氏族ID被编码在线程ID中以便快速比较。但是，低开销仅适用于可以直接通信的情况。一旦邮件被重定向，每个这样的重定向都会将两条邮件添加到（逻辑上）单个往返 IPC，这是一个巨大的开销。此外，严格的线程层次结构在实践中是笨拙的。对于强制访问控制，该模型很快恶化为每个进程为一个酋长。由于这些缺点，许多L4内核实现没有实现部落和酋长，或者在构建时禁用了该功能，但这意味着无法控制 IPC。该问题最终通过在端点上灵活地以功能为中介的访问控制得到解决。  
# 上下文切换

# 结论