# 毕业设计（论文）主要研究内容、进展情况及取得成果
本选题旨在调研现代微内核的发展趋势及性能瓶颈，利用用户态中断技术，设计和实现异步系统调用方案，减少微内核的系统调用开销，从而从提升微内核系统的资源利用率、系统调用时延和吞吐率。

研究的主要内容在于利用RISCV平台已有的用户态中断机制，利用改进后的通知机制以及共享内存，对ReL4微内核中的同步系统调用进⾏异步化改造，减少内核陷⼊和上下⽂切换次数，从⽽降低IPC开销，提升系统性能。 

研究关键点如下：
1. 理解ReL4中的同步IPC方式，了解ReL4的内核IPC路径以及重要内核对象如Capability、Untyped等。
2. 理解ReL4中的Notification机制以及异步IPC机制。
3. 在ReL4的Notification机制和异步IPC机制的基础上，开发异步系统调用。

在中期报告提交的时间节点前，项目进展如下：
1. 阅读参考文献《L4 microkernels: The lessons from 20 years of research and deployment》并翻译
2. 完成rel4实验环境部署
3. 了解sel4内核重要数据结构并阅读rel4系统调用路径源码
4. 完成rel4同步IPC时钟周期占比结果测试与分析
5. 完成rel4原有系统调用时钟周期占比结果测试与分析

因此，取得的成果如下：
1. rel4实验环境部署以及部署文档
2. rel4代码结构以及重要数据结构介绍文档
3. rel4同步IPC性能测试结果分析文档
4. rel4原有系统调用分析文档
5. 文献《L4 microkernels: The lessons from 20 years of research and deployment》翻译文档

通过对背景信息以及源代码的了解与分析可知，ReL4起源于seL4（Secure Embedded L4），seL4是一个高度安全的微内核，是L4微内核家族的成员，其设计目标是为了提供最高级别的安全性。seL4不仅作为一个操作系统内核，还在安全关键性应用中发挥着重要作用，如防御系统、汽车电子、航空电子和其他嵌入式系统领域。

seL4的一个显著特点是它是世界上第一个完全经形式验证的操作系统内核。形式验证是一个使用数学方法验证软件或硬件系统符合其规格说明的过程。这意味着seL4的实现被证明与其形式化的规格说明完全一致，保证没有任何功能性错误，并且确保完全按照设计的安全政策工作。这种级别的验证带来了前所未有的安全性保证。

此外，seL4使用一种称为Capability的机制来控制对系统资源的访问。Capability机制是一种seL4的核心安全特性，用于精确控制系统资源的访问权限，以提供强大的访问控制和细粒度的权限管理，从而增强系统的安全性和可靠性。

通过形式化验证和Capability机制提供的强大的安全特性和隔离性，seL4为需要高度安全性的系统提供了一个可靠的基础，特别是在越来越多的设备连接到互联网的今天，这种安全性变得尤为重要。虽然最初设计用于嵌入式和安全关键系统，seL4也被移植到了多种平台上，包括x86、ARM和RISC-V架构。

而Rust语言是一种安全、高性能、并发友好且具备现代化工具链的系统编程语言，可以为系统编程带来更高的效率和安全性，因此ReL4的开发者使用Rust语言重写了seL4的大部分内容，使得ReL4成为了支持seL4在RISC-V上的系统调用的微内核，且在内核结构和实现机制上采用与seL4相似的方法。ReL4 提供的核心功能如下：
1. 进程和线程管理：ReL4提供基本的进程管理功能，允许创建、执行、管理和终止进程和线程。它通过线程控制块（Thread Control Block，TCB）管理线程的执行。此部分功能实现在Task Manager模块中。
2. Capability系统：与seL4一致，ReL4 的安全性很大程度上依赖于其基于Capability机制的访问控制模型。具体而言，Capability是一种代表某种权限的标识符，它允许持有者对特定的系统资源（如内存页面、通信端点、线程等）进行操作。在ReL4中，每个资源都与一个或多个Capability绑定，而这些Capability存储在所谓的CSpace（Capability Space）中。每个进程拥有自己的CSpace。
3. 内存管理：内存管理在ReL4中是通过两种主要机制实现的：内存分配和内存保护。ReL4同样使用CSpace来控制对内存的访问，每个进程拥有自己的CSpace的特性保证了内存访问的安全性。而内存功能分配在Root Task中实现。
4. 通信机制：ReL4的IPC机制主要是通过端点（Endpoint）和通知（Notification）内核对象来完成的，这些机制支持线程之间的同步和异步通信。
5. 隔离和安全：通过上述的Capability系统和精细的资源管理，ReL4 实现了高级别的隔离。在ReL4中，不同的应用和服务可以在同一硬件平台上安全地并行运行，相互之间无法访问或干扰。
6. 定时器和调度：ReL4提供了基础的调度器支持，允许系统调度器管理线程的执行时间和顺序。此外，它还支持定时器管理，使系统和应用能够计划任务和管理时间。
7. 系统调用与中断处理：ReL4提供最基本的系统调用与中断处理模块。

ReL4微内核通过Rust语言安全性的加持和上述核心功能和设计模式，实现了一个安全、可靠且响应迅速的操作系统平台。但ReL4虽然在框架和机制实现上借鉴了seL4的设计方法，它并没有通过形式化验证的方式来确保代码运行的可靠性。因此在安全性方面，ReL4无法保证没有任何功能性错误，也无法实现与seL4一致的安全性保证。此外，不同于seL4提供了一层硬件抽象以使得内核可以在多种硬件平台上运行，包括 ARM, x86和RISC-V，ReL4仅支持seL4在RISC-V架构上的系统调用，因此只支持在RISC-V架构上运行上运行，这也限制了ReL4的实际运用范围。在未来的发展中ReL4或许应考虑参照seL4的抽象方法对更多硬件平台进行支持。

在实际应用中，ReL4 可以作为微内核提供基本的硬件隔离和基础服务，配合用户态服务器搭建操作系统。此外，ReL4也可以作为虚拟机监控器直接管理硬件资源，并提供在其基础上运行其他操作系统的支持，提供最佳性能和资源利用率。这一方案或将可作为未来ReL4的发展方向。

而具体到系统调用的实现，原有的ReL4微内核以同步IPC的方式进行系统调用，用户态线程需要主动调用微内核提供的接口陷入内核以请求系统调用服务。

ReL4原有的系统调用的底层机制采用IPC机制中的Call机制，该机制在IPC中负责向接收方发送消息，并阻塞等待接收方返回消息，参数的传递通过虚拟的消息寄存器进行。在系统调用的实现中，Call指令的接收方为ReL4微内核。用户态线程通过Call指令陷入内核后，系统调用的信息将被从消息寄存器中取出并进行解析，并由对应的处理程序处理，处理结果被写回消息寄存器。

除了上述底层通信机制的支持，ReL4微内核根据系统调用类型对将调用暴露给用户态的接口进行封装。ReL4中的系统调用主要分为两类：系统参数类调用以及与内核对象有关的系统调用。

系统参数类系统调用包含获取当前时钟周期的系统调用以及输出类的系统调用，该类系统调用无需经过内核复杂的处理，只需内核返回简单的数值甚至没有返回值，因此该类的用户态接口封装较为简单，只需在函数中调用接口最底层的Call接口并接收返回值即可。

与内核对象有关的系统调用涉及Capability机制，因此需要对Capability指针的编码与解码操作。为方便实现，ReL4设计了名为InvocationContext的Trait，该Trait封装了名为invoke的方法，该方法接受了一个操作目标内核对象的Capability指针的Rust闭包，在闭包中封装了底层的Call机制。通过对内核对象的Capability实现Trait特性，用户态程序即可通过调用内核对象的Capability的invoke方法陷入内核请求对内核对象有关操作系统资源的操作。

在了解上述机制的基础上，经过对源代码的仔细研读，ReL4中的系统调用的软硬件路径如下：
1. 用户态申请陷入
2. 硬件特权级切换
3. 保存辅助线程寄存器
4. 内核页表切换
5. 分发中断
6. 进入系统调用处理函数
7. 恢复用户态运行上下文返回用户态

通过对代码路径的时钟周期占比测试与分析，内核态和用户态的切换过程（包括硬件特权级切换、保存辅助线程寄存器、内核页表切换、分发中断以及最后的恢复用户态上下文并返回）已经成为ReL4微内核中系统调用所消耗时钟占比的主要部分。因此，如果能实现减少用户态和内核态的切换频率的系统调用方式，则可以很大地提升ReL4的系统调用性能。

# 存在的问题和解决方案
通过对工作进行总结与分析，得出目前存在的问题如下：
1. 此前的工作主要集中在seL4微内核设计知识补充以及ReL4代码框架阅读与理解方面，实际编写的代码主要用于服务测试，内容较为单一且行数较少。
2. 对于ReL4的运行框架的理解仅局限于同步IPC与系统调用主体部分的代码路径，其余部分代码的联系理解缺失。

因此，为更好地推进工作，与老师讨论后得出解决方案如下：
1. 尽快着手开始ReL4异步系统调用开发工作。
2. 尝试理顺ReL4代码框架。

# 下一步研究任务与进度安排
后续的研究任务在于利用上述的调研信息以及原有的设计思路，在ReL4操作系统中对同步系统调用进行异步化改造，实现异步系统调用设计框架。

结合毕设内容并与老师讨论后，下一阶段的进度安排如下：
1. 4.10-4.16: 更新代码并跑通基本的异步系统调用流程（包括用户态发送-内核处理-用户态接受回复三个部分）
2. 4.16-4.30: 在async_syscall_handler中翻译重要系统调用（本模块的主要开发工作，需要甄别哪些系统调用可以实现异步化），并在开发流程中完成异步系统调用模块的代码分析文档
3. 4.30-5.14: 设计方案并进行性能测试，论文撰写启动
4. 5.14-6.1: 论文撰写和毕设答辩工作

老师的指导意见如下：
1. 细化时间表
2. 加大时间投入
3. 在测试性能时可以以seL4为基准并进行对比