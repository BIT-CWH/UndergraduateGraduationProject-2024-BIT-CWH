# 题目

微内核操作系统ReL4中基于用户态中断的异步系统调用设计  
Design of Asynchronous System Call Based on User Mode Interrupt in Microkernel Operating System ReL4  

# 1. 选题依据

## 1.1 研究背景及意义

微内核是操作系统内核实现形式之一，它最小化了内核提供的功能：内核负责提供一组通用机制，如进程调度、内存管理等，而运行在用户态的服务器则实现了实际的操作系统服务。应用程序通过进程间通信（IPC）机制与相关服务器通信来获取系统服务。因此，IPC处于任何服务调用的关键路径上，低IPC成本至关重要。  
30年前，Liedtke用他的L4内核证明了微内核IPC可以很快，比当代微内核快10-20倍[5]。之后以seL4[1]为代表的微内核的IPC框架也基本延续了最初的L4，以同步IPC作为主要的通信方式，同时引入异步的通知机制来简化多线程程序设计，并提升多核的利用率。  
在目前的应用中，微内核的IPC性能已经有了很大的提升，而在IPC较为不频繁的应用中性能已经比较可观。但是在当应用中IPC需求频繁时，以往的IPC方式已经无法满足当代使用条件的需求，IPC的性能已经成为微内核的性能瓶颈，其过高的通讯成本甚至导致了将核心服务移回内核的趋势[2]：首先，微内核将操作系统的大部分服务（如网络协议栈、文件系统等）移到用户态，从而使得IPC数量和频率激增，内核态与用户态之间的上下文切换成为性能瓶颈。其次，现代微内核的外设驱动往往存在于用户态，外设中断被转化为通知信号，需要用户态驱动主动陷入内核来进行接收，这在很大程度上成为了外设驱动的性能瓶颈。  
综上，以seL4为代表的现代微内核在IPC和系统调用架构的设计上仍然无法很好满足现代高IPC频率进程的使用需求，本选题旨在调研现代微内核的发展趋势及性能瓶颈，利用用户态中断技术，设计和实现异步系统调用方案，减少微内核的系统调用开销，从而从提升微内核系统的资源利用率、系统调用时延和吞吐率。   

## 1.2 国内外研究现状

现代微内核的大部分IPC优化始于Liedtke提出的L4操作系统概念[1]。而以seL4为代表的现代微内核继承了L4的大部分优化手段，然而随着硬件的发展和软件需求的改变，部分优化方法已经无法适应硬件的发展和软件需求的变更，逐渐被遗弃和改进。目前的国内外在L4的基础上对于现代微内核IPC性能优化提升的研究主要可以分为以下三类：多核利用率、减少内核路径和减少特权级切换开销。  
在提升多核利用率方面，现代微内核多采用同步IPC的方式进行通信，最初的L4支持同步（交会式）IPC作为唯一的通信、同步和信号机制。而L4-embedded[6]通过添加Notification（一种简单的、非阻塞的信号机制）解决了L4具有的在多线程方面的复杂性问题。Notification不是异步IPC，而是将同步与通信进行解耦，对于有效利用硬件的并发性至关重要。后来的seL4也保留了同步IPC的模型，并通过进一步改进了Notification机制。OKL4已经完全放弃了同步IPC，取而代之的是虚拟IRQ（类似于通知）。NOVA通过计数信号量增强了同步IPC，而Fiasco.OC也通过虚拟IRQ增强了同步IPC[2]。  
在减少内核路径方面，原始的短消息传递采用物理消息寄存器，通过内核切换上下文时不更改消息寄存器的情况下进行。而Pistachio引入了虚拟消息寄存器的概念：将其中一些虚拟寄存器映射到物理寄存器，其余的则包含每个线程地址空间的固定部分中。而seL4和Fiasco.OC继续使用这种方法[2]。此模型优势在于，虚拟消息寄存器大大提高了跨架构的可移植性且减少了中等大小的消息超过物理寄存器数量的性能损失。而对于较长的消息，在原始L4中，“长”消息可以在单个IPC调用中指定多个缓冲区，以摊销硬件和上下文切换成本。但由于存在潜在的巨大的内核处理嵌套异常开销以及在实践中使用率低，长消息的方式在sel4中被弃用。  
在减少特权级切换开销方面，特权级的切换开销主要分为两类[7]：第一类是直接开销，主要是保存和恢复寄存器、模式切换等产生的开销。第二类则是间接开销，主要就是系统调用造成的L1 缓存污染以及快表（TLB）缓存失效等。原始的L4微内核敏锐地把握到了最常用的IPC组合模式（C/S模式），将Send & Recv两个系统调用组合为一个系统调用Call，同时将Recv & Send两个系统调用组合为一个系统调用RecvReply，通过组合系统调用的方式来减少特权级的切换次数[5]。此外，随着硬件的发展，ASID机制[8]被现代微内核用来减少TLB缓存失效问题，有效减小了页表的切换开销。  
基于L4的各种现代微内核的实现来看，随着对内核路径的优化逐步达到顶峰，对特权级切换开销的优化已经成为微内核中IPC优化的主要方向，特别是对于有频繁的短消息IPC以及频繁系统调用的应用，用户态-内核态的上下文切换已经成为了限制系统性能的最大瓶颈。  
而随着硬件的不断发展，用户态中断——一种新兴的硬件技术方案逐渐被各个硬件平台（x86、RISC-V）采纳。用户态中断通过硬件的方式，在无需陷入内核的情况下，将信号发送给其他用户态程序。该机制仅需在通信注册过程中陷入内核，以分配用于通信的相关硬件资源，后续的通信过程无需内核接入，很好地避免了用户态和内核态的上下文切换。ReL4是⽤Rust重写的支持seL4在RISCV上的系统调用的微内核，利用用户态中断绕过内核的特性，将共享内核和改造后的通知机制组合起来，实现了无需内核转发的异步IPC框架，当前的ReL4微内核以同步IPC进⾏系统调用。而内核作为一个特殊进程，在逻辑上同样可以被抽象为一个IPC的接收端，因此同样可以借助用户态中断来对系统调用进行异步化，从而消除系统调用的特权级切换。  

# 2. 研究目标

## 2.1 目标

本选题旨在调研现代微内核的发展趋势及性能瓶颈，利用用户态中断技术，设计和实现异步系统调用方案，减少微内核的系统调用开销，从而从提升微内核系统的资源利用率、系统调用时延和吞吐率。  

## 2.2 主要内容

研究的主要内容在于利用RISCV平台已有的用户态中断机制，利用改进后的通知机制以及共享内存，对ReL4微内核中的同步系统调用进⾏异步化改造，减少内核陷⼊和上下⽂切换次数，从⽽降低IPC开销，提升系统性能。  

## 2.3 关键问题

研究的关键问题在于充分调研用户态中断的机制，设计出合理的异步系统调用框架并进行实现，并在测试环境下进行一定的合理性验证。

# 3. 研究方案

## 3.1 编程语言选择

系统编程领域是一个需要高效利用硬件、同时关注代码安全性和可维护性的情境。而Rust语言的所有权和生命周期系统使得在编写系统级代码时更容易保障内存安全，减少潜在的漏洞和错误，其次，Rust提供了零成本抽象，使得开发者可以使用高层次的抽象，而无需担心性能问题。更重要的是，Rust的所有权和借用系统帮助避免了共享数据的并发问题，而其高级的并发库（如async/await）使得编写并发和并行代码更为容易。总体而言，Rust的特性使其成为一种安全、高性能、并发友好且具备现代化工具链的系统编程语言。因此本选题使用Rust语言在完全兼容seL4内核基本功能的微内核ReL4上开发基于用户态中断的系统调用。

## 3.2 设计方案

异步系统调用架构分为用户态和内核态两个部分。用户态提供的异步协程运行时允许用户态在等待系统调用结果时可以执行其他协程来减少CPU等待时间，实现分时并发；内核态提供的接受请求的协程则允许内核使用其他CPU核心来出处理系统调用请求，实现同时并行。

- 用户态运行时：在用户态运行时库中提供新的系统调用接口，待运行时初始化完成后，所有的用户态执行流都被封装到一个协程中，在协程中调用的系统调用会链接到新提供的运行时库中，将请求提交到syscall buffer，然后切换到其他协程进行执行。
- 内核运行时：内核启动后会维护一个内核运行时，在刚启动时为空，当有线程注册了异步系统调用的运行时之后，会新建一个Recv协程，添加到内核运行时，用于处理该线程的异步系统调用请求。
- 注册：用户态准备一块共享内存用于存放系统调用请求参数和请求结果等数据。然后调用 `register_async_syscall` 系统调用，在内核运行时中新建一个内核协程，该协程会遍历共享内存中的请求，当没有请求时会挂起该协程。（一个线程对应一个syscall buffer，对应一个内核协程）。
- 提交异步系统调用请求：用户态运行时在提交系统调用请求时会检查当前线程对应的内核协程是否已经被唤醒（syscall buffer中维护一个用户态可读的原子变量来获取内核协程状态）。
	- 如果对应的内核协程是被唤醒的，则将请求写入buffer后直接切换用户协程。
	- 如果对应的内核协程没有被唤醒，则陷入内核态，将对应的内核协程唤醒，并检查所有的核心是否有空闲的核心在：
		- 如果有：则向空闲核心发送IPI中断，让其执行内核协程。
		- 如果没有（所有的核心都在忙于处理用户态程序）：则直接返回到用户态切换用户协程，等到某个核心的时钟中断到来时再处理内核协程。
- 提交异步系统调用结果：内核协程在执行时能够很轻松的知道当前请求发起者（tcb，cid），以及tcb对应的syscall buffer，因此在处理完请求之后将对应的结果写入syscall res条目中，并根据tcb绑定的notification对象通知用户态中断处理程序，唤醒对应的用户态协程。

## 3.3 实验方案

baseline: seL4  
裸机：qemu，FPGA  
异步IPC的性能：  
- micro benchmark：每个IPC的切换周期数 vs 批量IPC下的平均IPC的切换周期数。  
- macro benchmark：选择需要大量IPC调用的应用：如Redis数据库读写等，测量平均延时和吞吐量。  

# 4. 研究计划及进度安排

2023年12月：完成选题工作。  
2024年1月-2024年2月：完成Rust语言学习、完成rCore实验并完成开题工作  
2024年3月-2024年4月：配置rel4环境并开始研究工作  
2024年4月-2024年5月：完成模型测试和中期答辩  
2024年5月-2024年6月：完成论文撰写和毕业设计答辩

# 5. 创新点及预期研究成果

在微内核中利用用户态中断机制减少上下文切换开销，并设计了异步的系统调用框架。  

# 6. 参考文献

[1] Klein G, Elphinstone K, Heiser G, et al. seL4: Formal verification of an OS kernel[C]//Proceedings of the ACM SIGOPS 22nd symposium on Operating systems
principles. 2009: 207-220.  
[2] Heiser G, Elphinstone K. L4 microkernels: The lessons from 20 years of research and deployment[J]. ACM Transactions on Computer Systems (TOCS), 2016, 34(1): 1-29.  
[3] Klimiankou Y. Micro-CLK: returning to the asynchronicity with communication-less microkernel[C]//Proceedings of the 12th ACM SIGOPS Asia-Pacific Workshop on Systems. 2021: 106-114.  
[4] Heiser G. The seL4 Microkernel–An Introduction[J]. The seL4 Foundation, 2020, 1.  
[5] Liedtke J. Improving IPC by kernel design[C]//Proceedings of the fourteenth ACM symposium on Operating systems principles. 1993: 175-188.  
[6] van Schaik C, Leslie B, Dannowski U, et al. NICTA L4-embedded kernel reference manual, version NICTA N1[R]. Technical report, National ICT Australia, October 2005. Latest version available from: http://www.ertos.nicta.com.au/research/l4.  
[7] Zhou Z, Bi Y, Wan J, et al. Userspace Bypass: Accelerating Syscall-intensive Applications[C]//17th USENIX Symposium on Operating Systems Design and Implementation (OSDI 23). 2023: 33-49.  
[8] Uhlig V, Dannowski U, Skoglund E, et al. Performance of address-space multiplexing on the Pentium[M]. Universität Karlsruhe, Fakultät für Informatik, 2002.

